Agora que as views (em htdocs), o model e o controller estão criados, vamos conectar tudo através do controlador

é o script justamente tarefa_controller.php que será o responsável por instanciar o objeto Tarefa e,
através de tarefaService, usando a conexao, controlar a persistência das tarefas dentro do Banco de Dados

logo, é em tarefa_controller.php vai centralizar os componentes da aplicação para que possamos 
fazer o insert de novos registros

1. criamos os requires

require "tarefa.model.php";
require "tarefa.model.php";
require "conexao.php";

Importante: por mais que as instruções de tarefa_controller aconteçam no script da pasta privada
as ações desse script serão executadas no contexto público pois tarefa_controller.php de htdocs contém apenas 
uma instrução:

require_once('../../../app_lista_de_tarefas/tarefa_controller.php');

ou seja, o arquivo da pasta pública faz uma requisição pro tarefa_controller.php da pasta privada

assim...ajustamos o Path dos requires como se estivessem sendo feito pelo script tarefa_controller.php de htdocs
logo, fica assim...

require "../../../app_lista_de_tarefas/tarefa.model.php";
require "../../../app_lista_de_tarefas/tarefa.service.php";
require "../../../app_lista_de_tarefas/conexao.php";


2. Agora que tudo está funcionando, temos enfim acesso às classes definidas nesses scripts

vamos então instanciar objetos dessas classes em tarefa_controller.php:

$tarefa = new Tarefa();
$tarefa->__set('tarefa', $_POST['tarefa']);

assim acessamos o objeto Tarefa e setamos o atributo 'tarefa' para receber os dados do formulário

3. O próximo passo é instanciar o objeto Conexao e o objeto tarefaService :


$conexao = new Conexao();

$tarefaService = new TarefaService();
$tarefaService->inserir();

* é o objeto TarefaService que vai recuperar o objeto Tarefa e a conexão para realizar ações 
junto ao Banco de dados
isso porque para realizar operações de CRUD, é necessário receber o objeto que queremos persistir
e também a conexão com o BD. 
Logo, nossa Classe TarefaService precisa receber essas duas informações por parâmetro para 
associar essas informações aos atributos do objeto TarefaService no momento de sua construção

4. Em tarefa.service.php vamos criar o método construtor

class TarefaService {

    private $conexao;
    private $tarefa;

    public function __construct(Conexao $conexao, Tarefa $tarefa){  // tipando os dados de entrada
        $this->conexao = $conexao;
        $this->tarefa = $tarefa;

    }
    ...

    * note a tipagem das variáveis em:   public function __construct(Conexao $conexao, Tarefa $tarefa)
    fizemos isso para garantir q o parâmetro $conexao é um objeto da classe Conexao e o mesmo com $tarefa


5. em tarefa_controller.php vamos ajustar os parâmetros do objeto TarefaService respeitando a ordem 
adotada na criação do objeto TarefaService

$tarefaService = new TarefaService($conexao, $tarefa);


nesse momento se debugarmos Conexao e TarefaService, teremos isso aqui:

Array
(
    [tarefa] => pagar condominio
)
TarefaService Object
(
    [conexao:TarefaService:private] => Conexao Object
        (
            [host:Conexao:private] => localhost
            [dbname:Conexao:private] => php_com_pdo
            [user:Conexao:private] => root
            [pass:Conexao:private] => 
        )

    [tarefa:TarefaService:private] => Tarefa Object
        (
            [id:Tarefa:private] => 
            [id_status:Tarefa:private] => 
            [tarefa:Tarefa:private] => pagar condominio
            [data_cadastro:Tarefa:private] => 
        )

)

No entanto o que queremos de fato guardar na variavel $conexao não é o objeto Conexao e sim o link de
conexão com o banco de dados contido no objeto PDO

para obter esse objeto é simples. Basta passar o método conectar() pra variável no momento da criação do objeto 
assim, no construct de TarefaService ao invés de 


    public function __construct(Conexao $conexao, Tarefa $tarefa){
        $this->conexao = $conexao;
        $this->tarefa = $tarefa;

vá com 

    public function __construct(Conexao $conexao, Tarefa $tarefa){
        $this->conexao = $conexao->conectar();
        $this->tarefa = $tarefa;

pois o método conectar() retorna esse link de conexão já trabalhado pela instância do obj PDO

agora ao debugar TarefaService o atributo conexao vai conter um objeto PDO , Beleza!


Array
(
    [tarefa] => pagar condominio
)
TarefaService Object
(
    [conexao:TarefaService:private] => PDO Object
        (
        )

    [tarefa:TarefaService:private] => Tarefa Object
        (
            [id:Tarefa:private] => 
            [id_status:Tarefa:private] => 
            [tarefa:Tarefa:private] => pagar condominio
            [data_cadastro:Tarefa:private] => 
        )

)


7. simbora trabalhar na function inserir() que vai passar a query de INSERT INTO pro nosso BD 


dentro do obj TarefaService vamos montar a query e protegê-la de SQL injection com prepare e bindValue...

  public function inserir(){ 
        $query = 'insert into tb_tarefas(tarefa) values(:tarefa)';
        $stmt = $this->conexao->prepare($query);
        $stmt->bindValue(':tarefa', $this->tarefa->__get('tarefa'));
      
        
    }

$this->tarefa->__get('tarefa') recupera o valor setado em tarefa_controller.php na instância do obj Tarefa
usamos __get() pois trata-se de um atributo privado

esse valor será adicionado ao statement através do identificador :tarefa 


8. Pronto! podemos agora executar!

  $stmt->execute();

Façamo-lo no momento apropriado, ou seja, falta chamar o método inserir no momento em q o objeto
TarefaService for instanciado lá em tarefa_controller.php

$tarefaService = new TarefaService($conexao, $tarefa);
$tarefaService->inserir();



E é isso! Agora já podemos preencher o formulário que, ao apertar o botão Cadastrar estaremos
efetuando com sucesso o registro dessa nova tarefa dentro da tb_tarefas no nosso banco de dados
